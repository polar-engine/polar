@uniform mat4 u_projection
@uniform float u_red
@uniform float u_green
@uniform float u_blue
@attrib vec2 a_vertex
@varying smooth vec2 v_vertex
@in color u_colorBuffer
@gin position u_posBuffer
@gin normal u_normalBuffer
@gin depth u_depthBuffer
@out rgba8 color o_color

@shader vertex

void main() {
	gl_Position = vec4(a_vertex, 0.0, 1.0);
	v_vertex = a_vertex / 2.0 + 0.5;
}

@shader fragment

vec3 Color(in vec2 texCoord) {
	return texture(u_colorBuffer, texCoord).rgb;
}

float Depth(in vec2 texCoord) {
	float f = 48.0;
	float n = 0.1;
	float z = (2 * n) / (f + n - texture(u_depthBuffer, texCoord).r * (f - n));
	return z;
}

#define SSAO_TOTAL_STRENGTH 0.38
#define SSAO_STRENGTH 0.07
#define SSAO_FALLOFF 0.000002
#define SSAO_RAD 0.006
#define SSAO_SAMPLES 8

float SSAORandom3(in vec3 coord) {
	return fract(sin(dot(coord, vec3(12.9898, 78.233, 323.525971))) * 43758.5453);
}

vec3 SSAO(in vec2 texCoord) {
	const vec3 sphere[8] = vec3[](vec3(0.24710192, 0.6445882, 0.033550154),vec3(0.00991752, -0.21947019, 0.7196721),vec3(0.25109035, -0.1787317, -0.011580509),vec3(-0.08781511, 0.44514698, 0.56647956),vec3(-0.011737816, -0.0643377, 0.16030222),vec3(0.035941467, 0.04990871, -0.46533614),vec3(-0.058801126, 0.7347013, -0.25399926),vec3(-0.24799341, -0.022052078, -0.13399573));

	vec3 pos = texture(u_posBuffer, v_vertex).xyz;
	vec3 rNormal = normalize(vec3(SSAORandom3(pos), SSAORandom3(pos + 1.13), SSAORandom3(pos + 2.323)));

	float depth = Depth(v_vertex);

	// screen-space fragment coords
	vec3 coord = vec3(v_vertex, depth);
	vec3 normal = texture(u_normalBuffer, v_vertex).xyz * 2.0 - 1.0;

	float bl = 0.0;

	for(int i = 0; i < SSAO_SAMPLES; ++i) {
		/* reflect random vector from sphere by random normal */
		vec3 ray = SSAO_RAD / depth * reflect(sphere[i], rNormal);

		/* if ray is outside hemisphere then change direction */
		vec3 dir = coord + sign(dot(ray, normal)) * ray;

		/* get normal of occluder fragment */
		vec3 occluderNorm = texture(u_normalBuffer, dir.xy).xyz * 2.0 - 1.0;

		/* if depthDifference is negative = occluder is behind current fragment */
		float depthDifference = depth - Depth(dir.xy);

		/* falloff equation, starts at falloff and falls like 1/x^2 */
		float normDiff = 1.0 - dot(occluderNorm, normal);
		bl += step(SSAO_FALLOFF, depthDifference) * normDiff * (1.0 - smoothstep(SSAO_FALLOFF, SSAO_STRENGTH, depthDifference));
	}

	float ao = 1.0 - SSAO_TOTAL_STRENGTH * bl / SSAO_SAMPLES;
	return Color(texCoord) * ao;
}

#define CEL_MIN_DEPTH 0

float CelDepth(in vec2 texCoord) {
	float depthRange = 1.0 / 64.0;
	float lowerDepth = 1.0 - depthRange;
	return (texture(u_depthBuffer, texCoord).r - lowerDepth) / depthRange;
}

vec3 Cel(in vec2 texCoord) {
	vec3 color = SSAO(texCoord);

	vec2 factor = 1.0 / vec2(textureSize(u_colorBuffer, 0));

	vec2 north = texCoord + vec2( 0,  factor.y);
	vec2 south = texCoord + vec2( 0, -factor.y);
	vec2 east  = texCoord + vec2( factor.x,  0);
	vec2 west  = texCoord + vec2(-factor.x,  0);

	float depth      = max(CEL_MIN_DEPTH, CelDepth(texCoord));
	float depthNorth = max(CEL_MIN_DEPTH, CelDepth(north));
	float depthSouth = max(CEL_MIN_DEPTH, CelDepth(south));
	float depthEast  = max(CEL_MIN_DEPTH, CelDepth(east));
	float depthWest  = max(CEL_MIN_DEPTH, CelDepth(west));
	float depthNS = (depthNorth + depthSouth) / 2.0;
	float depthEW = (depthEast + depthWest) / 2.0;
	float diffV = abs(depth - depthNS);
	float diffH = abs(depth - depthEW);
	float diff = (diffV + diffH) / 2.0;

	if(diffV + diffH > 0.0001) {
		vec3 colorNorth = mix(SSAO(north), color, diffV);
		vec3 colorSouth = mix(SSAO(south), color, diffV);
		vec3 colorEast  = mix(SSAO(east), color, diffH);
		vec3 colorWest  = mix(SSAO(west), color, diffH);

		vec3 newColor = color;
		newColor += (colorNorth + colorSouth + colorEast + colorWest) * (depthNS + depthEW) / 2.0;
		newColor /= 5.0;

		const float NEAR = 0.6;
		const float FAR = 0.999999995;
		color = mix(color, newColor, clamp((depth - NEAR) / (FAR - NEAR), 0.0, 1.0));
	}

	return color;
}

void main(void) {
	o_color.rgb = Cel(v_vertex);
	o_color.a = 1.0;
}

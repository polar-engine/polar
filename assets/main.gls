@uniform mat4 u_camera
@uniform mat4 u_modelView
@uniform mat4 u_projection
@attrib vec3 a_vertex
@attrib vec3 a_normal
@varying smooth vec4 v_vertex
@varying flat vec4 v_normal
@out color color o_color
@gout color normal o_normal
@gout depth depth

@shader vertex

void main() {
	v_vertex = u_modelView * vec4(a_vertex, 1.0);
	v_normal = u_modelView * vec4(a_normal, 0.0);
	gl_Position = u_projection * v_vertex;
}

@shader fragment

vec3 light(in vec3 lightPosition, in vec3 color, in float shininess, in float radius) {
	vec3 ambient = vec3(0.01);

	vec3 lightPos = vec3(/*u_camera * */vec4(lightPosition, 1.0));
	vec3 vAux = lightPos - vec3(v_vertex);
	vec3 lightDir = normalize(vAux);
	float distance = length(vAux);

	float diffuseAttenuation = clamp(1.0 - distance * distance / (radius * radius), 0.0, 1.0);
	diffuseAttenuation *= diffuseAttenuation;

	//diffuseAttenuation = 1.0;// / (0.2 + 0.05 * distance * distance);

	float nDotL = max(0.0, dot(vec3(v_normal), lightDir));
	vec3 diffuse = color * nDotL * diffuseAttenuation;

	vec3 specular = vec3(0.0, 0.0, 0.0);
	if(nDotL > 0.0) {
		vec3 halfway = normalize(lightDir + normalize(vec3(-v_vertex)));
		float nDotH = max(0.0, dot(vec3(v_normal), halfway));
		float specularAttenuation = diffuseAttenuation;
		specular += sqrt(color) * pow(nDotH, shininess) * specularAttenuation;
	}
	vec3 final = ambient + diffuse + specular;
	return final;
}

void main() {
	vec3 final = vec3(0.0);
	final += light(vec3(0.0), vec3(1.0, 0.5, 0.0) * 1.0, 64.0, 60.0);
	//final += light(vec3(0.0), vec3(0.74, 0.7, 1.0) * 1.0, 64.0, 60.0);
	//final += light(vec4(10.0, 0.0, -5.0, 1.0), vec3(1.0, 0.7, 0.74), 256.0, 40.0);

	vec3 hdr = 1.0 - exp2(-final * 1.52);
	hdr *= max(1.0, length(final) / 2);
	final = hdr;

	o_color = vec4(final, 1.0);
	o_normal = v_normal;
}

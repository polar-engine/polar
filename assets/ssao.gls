@uniform mat4 u_projection
@uniform uint u_time

@attrib vec2 a_vertex

@varying smooth vec2 v_vertex

@in color u_colorBuffer
@gin normal u_normalBuffer
@gin depth u_depthBuffer
@out rgba8 color o_color

@shader vertex

void main() {
	gl_Position = vec4(a_vertex, 0.0, 1.0);
	v_vertex = (a_vertex + 1.0) / 2.0;
}

@shader fragment

float Random(float coord) {
	return fract(sin(dot(coord, 12.9898)) * 43758.5453);
}

float Random2(vec2 coord) {
	return fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453);
}

float Random3(vec3 coord) {
	return fract(sin(dot(coord, vec3(12.9898, 78.233, 323.525971))) * 43758.5453);
}

const float totalStrength = 0.38;
const float strength = 0.07;
const float falloff = 0.000002;
const float rad = 0.006;

#define SAMPLES 8
const float invSamples = 1.0 / SAMPLES;

float Depth(in vec2 texCoord) {
	float f = 48.0;
	float n = 0.1;
	float z = (2 * n) / (f + n - texture(u_depthBuffer, texCoord).r * (f - n));
	return z;
}

void main(void) {
	const vec3 sphere[8] = vec3[](vec3(0.24710192, 0.6445882, 0.033550154),vec3(0.00991752, -0.21947019, 0.7196721),vec3(0.25109035, -0.1787317, -0.011580509),vec3(-0.08781511, 0.44514698, 0.56647956),vec3(-0.011737816, -0.0643377, 0.16030222),vec3(0.035941467, 0.04990871, -0.46533614),vec3(-0.058801126, 0.7347013, -0.25399926),vec3(-0.24799341, -0.022052078, -0.13399573));

	float seconds = float(u_time) / 10000.0;
	vec3 pos = vec3(seconds, seconds * 1.3167, seconds * 1.7543);
	vec3 rNormal = normalize(vec3(Random3(pos), Random3(pos + 1.13), Random3(pos + 2.323)));

	float depth = Depth(v_vertex);

	// screen-space fragment coords
	vec3 coord = vec3(v_vertex, depth);
	vec3 normal = texture(u_normalBuffer, v_vertex).xyz * 2.0 - 1.0;

	float bl = 0.0;

	for(int i = 0; i < SAMPLES; ++i) {
		/* reflect random vector from sphere by random normal */
		vec3 ray = rad / depth * reflect(sphere[i], rNormal);

		/* if ray is outside hemisphere then change direction */
		vec3 dir = coord + sign(dot(ray, normal)) * ray;

		/* get normal of occluder fragment */
		vec3 occluderNorm = texture(u_normalBuffer, dir.xy).xyz * 2.0 - 1.0;

		/* if depthDifference is negative = occluder is behind current fragment */
		float depthDifference = depth - Depth(dir.xy);

		/* falloff equation, starts at falloff and falls like 1/x^2 */
		float normDiff = 1.0 - dot(occluderNorm, normal);
		bl += step(falloff, depthDifference) * normDiff * (1.0 - smoothstep(falloff, strength, depthDifference));
	}
	float ao = 1.0 - totalStrength * bl * invSamples;
	o_color.rgb = texture(u_colorBuffer, v_vertex).rgb * ao;
	o_color.a = 1.0;
}

@uniform mat4 u_projection
@attrib vec2 a_vertex
@varying smooth vec2 v_vertex
@in color u_colorBuffer
@gin normal u_normalBuffer
@gin depth u_depthBuffer
@out color color o_color

@shader vertex

void main() {
	gl_Position = vec4(a_vertex, 0.0, 1.0);
	v_vertex = (a_vertex + 1.0) / 2.0;
}

@shader fragment

const int kernelSize = 16;
const float kernelScale = 0.1;
const float noiseScale = 0.1;
const float radius = 3.0;

float Depth(in vec2 texCoord) {
	float f = 64.0;
	float n = 0.01;
	float z = (2 * n) / (f + n - texture(u_depthBuffer, texCoord).r * (f - n));
	return z;
}

float Random(float coord) {
	return fract(sin(dot(coord, 12.9898)) * 43758.5453);
}

float Random3(vec3 coord) {
	return fract(sin(dot(coord, vec3(12.9898, 78.233, 323.525971))) * 43758.5453);
}

void main() {
	vec2 texCoord = v_vertex;

	float aspect = 1280.0 / 720.0;
	float thfov = tan(70.0 / 2.0);
	vec2 ndc = texCoord * 2.0 - 1.0;
	vec3 viewRay = vec3(ndc.x * thfov * aspect, ndc.y * thfov, 1.0);
	vec3 origin = viewRay * Depth(texCoord);

	vec3 normal = normalize(texture(u_normalBuffer, texCoord).xyz * 2.0 - 1.0);
	vec3 rvec = vec3(Random3(vec3(normal.xy * noiseScale, 0.0)), Random3(vec3(normal.xz * noiseScale, 1.0)), Random3(vec3(normal.yz * noiseScale, 2.0)));
	vec3 tangent = normalize(rvec - normal * dot(rvec, normal));
	vec3 bitangent = cross(normal, tangent);
	mat3 tbn = mat3(tangent, bitangent, normal);

	vec3 kernel[kernelSize];
	for(int i = 0; i < kernelSize; ++i) {
		kernel[i] = vec3(
			Random(float(i * 50 + 0)),
			Random(float(i * 50 + 1)),
			Random(float(i * 50 + 2)) / 2.0 + 0.5
		);
		kernel[i] = normalize(kernel[i]);
		kernel[i] *= Random(float(i * 50 + 3)) / 2.0 + 0.5;

		float scale = float(i) / kernelSize;
		scale = mix(0.1, 1.0, scale * scale);
		kernel[i] *= scale;
	}

	float occlusion = 0.0;
	for(int i = 0; i < kernelSize; ++i) {
		vec3 sample = tbn * kernel[i];
		sample = sample * radius + origin;

		vec4 offset = vec4(sample, 1.0);
		offset = u_projection * offset;
		offset.xy /= offset.w;
		offset.xy = offset.xy * 0.5 + 0.5;

		float sampleDepth = Depth(-offset.xy);

		float rangeCheck = abs(origin.z - sampleDepth) < radius ? 1.0 : 0.0;
		occlusion += (sampleDepth <= sample.z ? 1.0 : 0.0);// * rangeCheck;
	}
	occlusion = 1.0 - occlusion / kernelSize;

	o_color = texture(u_colorBuffer, texCoord) * occlusion;
}